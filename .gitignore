# ╔══════════════════════════════════════════════════════════════════════════════╗
# ║                                                                            ║
# ║                         .gitignore — Master File                           ║
# ║                                                                            ║
# ║   Project:  Node.js / TypeScript Server                                    ║
# ║   Bundler:  esbuild                                                        ║
# ║   Targets:  Serverless (Lambda, Cloud Functions) & Container (Docker, ECS) ║
# ║                                                                            ║
# ╠══════════════════════════════════════════════════════════════════════════════╣
# ║                                                                            ║
# ║   PHILOSOPHY                                                               ║
# ║                                                                            ║
# ║   This file follows three guiding principles:                              ║
# ║                                                                            ║
# ║   1. REPRODUCIBILITY — Every developer and CI runner must produce          ║
# ║      identical results from the same commit. We track lock files and       ║
# ║      config, but ignore anything that can be regenerated.                  ║
# ║                                                                            ║
# ║   2. SECURITY — Secrets never enter the repository. Not in env files,     ║
# ║      not in service account JSON, not in private keys. The only            ║
# ║      exception is .env.example, which documents required variables         ║
# ║      without containing real values.                                       ║
# ║                                                                            ║
# ║   3. SIGNAL OVER NOISE — The repository contains source code, config,     ║
# ║      documentation, and tests. Everything else — build output, caches,     ║
# ║      editor state, OS metadata — is noise that obscures meaningful         ║
# ║      diffs and bloats clone times.                                         ║
# ║                                                                            ║
# ║   Negation patterns (!) are used sparingly and deliberately. Each one      ║
# ║   has a comment explaining why the file deserves to be tracked despite     ║
# ║   matching a broader exclusion rule.                                       ║
# ║                                                                            ║
# ╚══════════════════════════════════════════════════════════════════════════════╝


# ┌──────────────────────────────────────────────────────────────────────────────┐
# │                                                                              │
# │   SECTION 1: BUILD ARTIFACTS & OUTPUT                                        │
# │                                                                              │
# │   Build output is always regenerable from source. Committing it causes       │
# │   merge conflicts, inflates repo size, and creates a false sense of          │
# │   what "changed" in a PR. The dist/ folder is produced by build.ts           │
# │   and should be created fresh in every CI pipeline.                          │
# │                                                                              │
# └──────────────────────────────────────────────────────────────────────────────┘

# Primary build output directory (esbuild → dist/server.mjs)
dist/

# esbuild writes a metafile.json for bundle analysis tools like
# esbuild-visualizer or bundle-buddy. Useful locally, not in version control.
metafile.json

# Source maps — generated alongside the bundle. They can be large and
# contain inlined source content. Deploy pipelines should generate their own.
*.map
*.js.map
*.mjs.map

# Compiled JavaScript emitted from TypeScript when using tsc directly
# (e.g., for type-checking scripts or migration utilities).
# We track .ts source only; .js output is derived.
*.js
!*.config.js
!*.config.cjs
!*.config.mjs
# ↑ Config files like jest.config.js, eslint.config.js, commitlint.config.js
#   are authored as JS and SHOULD be tracked. The negation above preserves them.

# TypeScript declaration output — only relevant if publishing a library.
# For a server project, these are build artifacts.
*.d.ts
*.d.ts.map
*.d.mts
*.d.mts.map

# tsc --build mode incremental compilation cache
*.tsbuildinfo

# esbuild cache directory (used by some plugin configurations)
.esbuild/

# Generic build cache directories used by various tools
.build/
.cache/
build/
# ↑ If your project has a "build/" directory that IS source (e.g., build scripts),
#   remove this line and rely on dist/ exclusion instead.

# Temporary output from bundler experiments or one-off scripts
out/
output/
tmp-build/


# ┌──────────────────────────────────────────────────────────────────────────────┐
# │                                                                              │
# │   SECTION 2: DEPENDENCIES                                                   │
# │                                                                              │
# │   node_modules/ is the single largest source of repo bloat. It is fully      │
# │   reproducible from the lock file, which IS committed. Each package          │
# │   manager has its own cache and metadata files — we exclude them all         │
# │   except the lock file itself.                                               │
# │                                                                              │
# │   LOCK FILE STRATEGY:                                                        │
# │   ✓ COMMIT your primary lock file (package-lock.json, pnpm-lock.yaml,       │
# │     or yarn.lock). It guarantees deterministic installs.                     │
# │   ✗ Do NOT commit lock files from package managers you don't use.            │
# │     If you use npm, ignore yarn.lock and pnpm-lock.yaml, etc.               │
# │     Uncomment the appropriate lines below for your project.                  │
# │                                                                              │
# └──────────────────────────────────────────────────────────────────────────────┘

# All installed packages — always regenerable from the lock file
node_modules/

# ── npm ──────────────────────────────────────────────────────────────
# npm debug logs written during install failures
npm-debug.log*
# npm pack output (see Section 10)
*.tgz
# npm cache directory (rarely appears in project root, but just in case)
.npm/

# ── pnpm ─────────────────────────────────────────────────────────────
# pnpm store — the content-addressable global store link
.pnpm-store/
# pnpm debug logs
pnpm-debug.log*

# ── Yarn v1 (Classic) ───────────────────────────────────────────────
# Yarn integrity file (ensures node_modules matches yarn.lock)
.yarn-integrity

# ── Yarn v3+ (Berry / PnP) ──────────────────────────────────────────
# Yarn Berry stores unplugged packages and its cache locally.
# In "zero-install" mode you WOULD track .yarn/cache — but for a server
# project built in CI, we exclude it to keep the repo lean.
.yarn/cache
.yarn/unplugged
.yarn/build-state.yml
.yarn/install-state.gz
# ↓ These Yarn Berry files SHOULD be tracked — they configure Yarn itself.
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/sdks
!.yarn/versions
# .pnp.cjs and .pnp.loader.mjs enable Yarn Plug'n'Play resolution.
# Ignore them unless your project uses PnP (uncomment to track if it does).
.pnp.*

# ── Uncomment ONE of the following blocks based on your package manager ──

# If you use npm (keep package-lock.json, ignore others):
# pnpm-lock.yaml
# yarn.lock

# If you use pnpm (keep pnpm-lock.yaml, ignore others):
# package-lock.json
# yarn.lock

# If you use yarn (keep yarn.lock, ignore others):
# package-lock.json
# pnpm-lock.yaml

# ── Patch files ──────────────────────────────────────────────────────
# patch-package / pnpm patch output — these SHOULD be tracked because they
# contain intentional fixes to dependencies. DO NOT ignore the patches/ dir.
# patches/  ← intentionally NOT listed here


# ┌──────────────────────────────────────────────────────────────────────────────┐
# │                                                                              │
# │   SECTION 3: ENVIRONMENT & SECRETS                                           │
# │                                                                              │
# │   This is the most security-critical section. A single .env file with        │
# │   real credentials committed to git is a data breach waiting to happen —     │
# │   even in a private repo (clones, forks, CI logs, laptop theft).             │
# │                                                                              │
# │   We whitelist .env.example as the ONLY env-like file allowed in the repo.   │
# │   It documents the required variables with placeholder values so new          │
# │   developers can get started without Slack-messaging for secrets.            │
# │                                                                              │
# └──────────────────────────────────────────────────────────────────────────────┘

# ── Environment files ────────────────────────────────────────────────
# Catch all .env variants: .env, .env.local, .env.development, .env.production,
# .env.staging, .env.test, .env.dev, etc.
.env
.env.*

# ↓ Exception: the example/template file with placeholder values IS tracked.
#   It serves as living documentation of which variables the app expects.
!.env.example
!.env.template

# ── Private keys & certificates ──────────────────────────────────────
# TLS/SSL certificates and private keys used for local HTTPS or mTLS
*.pem
*.key
*.crt
*.cert
*.p12
*.pfx
*.jks

# SSH keys (should never be in a project directory, but defense in depth)
id_rsa
id_rsa.pub
id_ed25519
id_ed25519.pub
*.pub
# ↑ Be careful: this catches all .pub files. If your project generates
#   .pub files for another purpose, make them more specific or negate here.

# ── Cloud credentials & service accounts ─────────────────────────────
# Google Cloud service account keys — JSON files with full API access
*-service-account.json
*-credentials.json
*service-account*.json
gcloud-credentials.json
firebase-adminsdk*.json

# AWS credentials file (should live in ~/.aws, not project root)
.aws/
credentials
aws-credentials.json

# Azure service principal files
azure-credentials.json

# ── npm authentication ───────────────────────────────────────────────
# .npmrc can contain auth tokens for private registries.
# If your .npmrc has ONLY non-sensitive config (like registry URLs),
# you can negate this and track it.
.npmrc

# ── Docker secrets ───────────────────────────────────────────────────
# Docker secrets mount directory
secrets/
*.secret
docker-secrets/

# ── Vault & secrets manager cache ────────────────────────────────────
.vault-token
.vault/


# ┌──────────────────────────────────────────────────────────────────────────────┐
# │                                                                              │
# │   SECTION 4: IDE & EDITOR                                                   │
# │                                                                              │
# │   Editor configurations are personal preference — except when they're not.   │
# │   Some teams share VS Code settings for consistent formatting, debug         │
# │   configs, and recommended extensions. This file takes the conservative      │
# │   approach: ignore everything, then selectively whitelist shared configs.    │
# │                                                                              │
# └──────────────────────────────────────────────────────────────────────────────┘

# ── VS Code ──────────────────────────────────────────────────────────
.vscode/*

# ↓ SELECTIVELY TRACK shared VS Code config. Uncomment lines your team agrees on.
# !.vscode/settings.json      # Shared formatting, ruler, file association settings
# !.vscode/extensions.json    # Recommended extensions list for the project
# !.vscode/launch.json        # Shared debug configurations
# !.vscode/tasks.json         # Shared build/test task definitions

# ── JetBrains (WebStorm, IntelliJ IDEA, etc.) ───────────────────────
# The .idea/ directory contains project settings, many of which are personal.
.idea/

# JetBrains generates workspace-specific XML files
*.iml
*.iws
*.ipr

# JetBrains HTTP client environment files (may contain tokens)
.idea/httpRequests/
http-client.private.env.json

# ── Vim / Neovim ─────────────────────────────────────────────────────
# Swap files created when Vim crashes or a file is opened in two sessions
*.swp
*.swo
*.swn
*~

# Neovim undo history
*.un~

# Session files
Session.vim
Sessionx.vim

# Vim tags file (generated by ctags)
tags
tags.lock
tags.temp

# ── Emacs ────────────────────────────────────────────────────────────
# Backup files (file~ or file.~n~)
*~
\#*\#

# Auto-save files
.\#*

# Emacs desktop save files
.emacs.desktop
.emacs.desktop.lock

# Flycheck temp files
flycheck_*.el

# Directory-local variables
.dir-locals.el

# ── Sublime Text ─────────────────────────────────────────────────────
*.sublime-workspace
# ↓ .sublime-project CAN be tracked if your team standardizes on Sublime.
#   It defines build systems and settings. Usually ignored for server projects.
*.sublime-project

# ── Other editors & tools ────────────────────────────────────────────
# Zed editor
.zed/

# Nova (macOS editor by Panic)
.nova/

# Cursor (AI-powered editor)
.cursorignore
.cursor/


# ┌──────────────────────────────────────────────────────────────────────────────┐
# │                                                                              │
# │   SECTION 5: OS-GENERATED FILES                                              │
# │                                                                              │
# │   Every operating system sprinkles metadata files across directories.        │
# │   These are meaningless to the project but pollute diffs and cause           │
# │   merge conflicts between developers on different platforms. A global        │
# │   ~/.gitignore_global is the proper place for these, but defense-in-depth   │
# │   means we catch them here too.                                              │
# │                                                                              │
# └──────────────────────────────────────────────────────────────────────────────┘

# ── macOS ────────────────────────────────────────────────────────────
# Finder metadata (folder view options, icon positions)
.DS_Store
.DS_Store?

# Resource forks — legacy metadata attached to files on network shares
._*

# Spotlight full-text index stores
.Spotlight-V100

# Trash folder on mounted volumes
.Trashes

# Finder folder icon customization
Icon?
# ↑ The ? matches the invisible \r character Finder appends to the filename.

# Disk image metadata
.fseventsd
.VolumeIcon.icns
.com.apple.timemachine.donotpresent

# macOS tags and extended attributes
.AppleDouble
.LSOverride
.AppleDB
.AppleDesktop
Network Trash Folder
Temporary Items
.apdisk

# ── Windows ──────────────────────────────────────────────────────────
# Thumbnail cache files
Thumbs.db
Thumbs.db:encryptable
ehthumbs.db
ehthumbs_vista.db

# Folder display settings
desktop.ini
Desktop.ini

# Recycle Bin used on file shares
$RECYCLE.BIN/

# Windows Installer cache
*.cab
*.msi
*.msix
*.msm
*.msp

# Windows shortcuts (occasionally auto-generated)
*.lnk

# ── Linux ────────────────────────────────────────────────────────────
# Lost directory fragments from filesystem repair (ext4, xfs)
lost+found/

# Lock files from LibreOffice/OpenOffice (if someone edits docs in repo)
.~lock.*


# ┌──────────────────────────────────────────────────────────────────────────────┐
# │                                                                              │
# │   SECTION 6: TESTING & COVERAGE                                              │
# │                                                                              │
# │   Test coverage reports and test runner caches are generated output.          │
# │   They change with every run and can be enormous (HTML reports with           │
# │   syntax-highlighted source). CI should generate fresh coverage data;         │
# │   local reports are for the developer's eyes only.                           │
# │                                                                              │
# │   NOTE ON SNAPSHOTS: Jest/Vitest __snapshots__ directories SHOULD be         │
# │   tracked — they are the "expected output" of snapshot tests and             │
# │   reviewers need to see when they change. Do NOT add __snapshots__           │
# │   to .gitignore.                                                             │
# │                                                                              │
# └──────────────────────────────────────────────────────────────────────────────┘

# ── Coverage output (all tools write to one of these) ────────────────
coverage/
.coverage/
*.lcov
.nyc_output/

# c8 (Node.js native V8 coverage) output
.c8_output/

# Coveralls intermediate file
coveralls.json

# ── Jest ─────────────────────────────────────────────────────────────
# Jest cache directory (speeds up subsequent runs)
jest_cache/
.jest-cache/

# ── Vitest ───────────────────────────────────────────────────────────
# Vitest caches type-check and transform results
.vitest/

# ── Playwright ───────────────────────────────────────────────────────
# Playwright stores test results, screenshots, video recordings, and traces.
# These can be hundreds of MB for visual regression suites.
test-results/
playwright-report/
playwright/.cache/
blob-report/

# Playwright screenshots and videos from test runs
e2e/screenshots/
e2e/videos/

# ── Cypress (if used alongside or migrated from) ────────────────────
cypress/screenshots/
cypress/videos/
cypress/downloads/

# ── Stryker (mutation testing) ───────────────────────────────────────
.stryker-tmp/
reports/mutation/


# ┌──────────────────────────────────────────────────────────────────────────────┐
# │                                                                              │
# │   SECTION 7: LOGS & DIAGNOSTICS                                              │
# │                                                                              │
# │   Log files are ephemeral, environment-specific, and potentially contain     │
# │   sensitive data (request bodies, user IDs, tokens in URLs). They have       │
# │   no place in version control. Node.js also generates diagnostic reports     │
# │   and heap snapshots when things go wrong — useful for debugging, but        │
# │   often contain memory contents that could include secrets.                  │
# │                                                                              │
# └──────────────────────────────────────────────────────────────────────────────┘

# ── Application logs ─────────────────────────────────────────────────
logs/
*.log

# Rotated / numbered / dated log files
*.log.*
*.log-*

# ── npm / pnpm / yarn install logs ──────────────────────────────────
npm-debug.log*
pnpm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*

# ── Node.js diagnostic reports ───────────────────────────────────────
# Generated by --report-on-signal, --report-on-fatalerror, or process.report
# Contains heap statistics, stack traces, environment variables, and
# shared library addresses. Treat as potentially sensitive.
report.*.json
report.[0-9]*

# ── Heap & core dumps ───────────────────────────────────────────────
# V8 heap snapshots (generated by --heapsnapshot-signal or Chrome DevTools)
*.heapsnapshot
*.heapprofile

# Core dumps from segfaults or abort() (Linux/macOS)
core
core.*
vgcore.*

# ── PID file
